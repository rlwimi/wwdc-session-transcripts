WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:07.516 --> 00:00:17.500 A:middle
[ Music ]

00:00:23.536 --> 00:00:24.746 A:middle
&gt;&gt; So hi, everybody.

00:00:25.516 --> 00:00:30.596 A:middle
[ Applause ]

00:00:31.096 --> 00:00:33.406 A:middle
I'm Melissa, I'm one of
the core data engineers

00:00:33.866 --> 00:00:36.036 A:middle
and this literally the first
year that no one has told me

00:00:36.036 --> 00:00:39.306 A:middle
to break a leg before I go out
on stage, because frankly I did

00:00:39.306 --> 00:00:40.826 A:middle
that a month ago and
this my first day

00:00:40.826 --> 00:00:42.026 A:middle
without a cast [laughter].

00:00:42.116 --> 00:00:44.036 A:middle
So if I'm limping around
you'll know what happened.

00:00:45.516 --> 00:00:47.556 A:middle
[ Applause ]

00:00:48.056 --> 00:00:49.606 A:middle
So one of the best
parts of working

00:00:49.606 --> 00:00:50.966 A:middle
on core data is actually
being able to get

00:00:50.966 --> 00:00:53.996 A:middle
up on stage here every year
and tell you guys like what new

00:00:53.996 --> 00:00:56.406 A:middle
and interesting stuff
we've been doing and boy,

00:00:56.406 --> 00:00:58.796 A:middle
this year we have a lot of it,
and it's really useful and we,

00:00:59.006 --> 00:01:00.286 A:middle
we hope you're going to love it.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:00:59.006 --> 00:01:00.286 A:middle
we hope you're going to love it.

00:01:01.306 --> 00:01:03.456 A:middle
So I'm going to talk about a
new feature, query generations,

00:01:03.456 --> 00:01:05.866 A:middle
some changes in the core
data concurrency world.

00:01:05.966 --> 00:01:09.106 A:middle
I'm going to talk about some
new stuff we've done in the area

00:01:09.106 --> 00:01:12.276 A:middle
of core data stack configuration
and some new APIs we've added.

00:01:12.876 --> 00:01:15.676 A:middle
And we're going to talk a
bit about what we've done

00:01:15.676 --> 00:01:18.896 A:middle
to integrate more neatly and
cleanly with Swift and some

00:01:18.896 --> 00:01:19.956 A:middle
of the improvements we've made

00:01:19.956 --> 00:01:21.856 A:middle
in the area of Xcode
integration.

00:01:22.736 --> 00:01:26.166 A:middle
And that's a lot so, on with
the first, query generations.

00:01:27.636 --> 00:01:29.486 A:middle
Query generations is a
new feature we've added

00:01:29.576 --> 00:01:31.346 A:middle
but before I sort
of get into talking

00:01:31.346 --> 00:01:32.696 A:middle
about query generations
I need to talk

00:01:32.696 --> 00:01:33.596 A:middle
about faults a little bit.

00:01:34.406 --> 00:01:37.336 A:middle
Core data uses faults a lot,
as some of you may know.

00:01:38.016 --> 00:01:40.036 A:middle
Manage objects can be faults,

00:01:40.106 --> 00:01:41.626 A:middle
their relationships
can be faults,

00:01:41.766 --> 00:01:43.266 A:middle
and if you're using
batch fetching,

00:01:43.636 --> 00:01:44.946 A:middle
then the array you get back

00:01:45.066 --> 00:01:47.876 A:middle
from NSManagedObjectContext
execute fetch request,

00:01:47.876 --> 00:01:49.346 A:middle
is going to be a very
specialized fault.

00:01:50.006 --> 00:01:52.606 A:middle
So that being said,
what is a fault?

00:01:53.096 --> 00:01:56.406 A:middle
Well, up here on the
screen I've got a picture

00:01:56.406 --> 00:01:59.316 A:middle
of an object graph, I've got
a country, the United States.

00:01:59.986 --> 00:02:01.916 A:middle
State, California,
couple of counties,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:01:59.986 --> 00:02:01.916 A:middle
State, California,
couple of counties,

00:02:02.026 --> 00:02:03.366 A:middle
Santa Clara and San Francisco.

00:02:03.866 --> 00:02:07.696 A:middle
And some cities in Santa
Clara, San Jose and Cupertino.

00:02:08.726 --> 00:02:09.795 A:middle
And some of this is a piece

00:02:09.795 --> 00:02:12.976 A:middle
of like a tourist guide a
guidebook, something you can go

00:02:12.976 --> 00:02:15.596 A:middle
in and navigate through
to find points of interest

00:02:15.656 --> 00:02:18.366 A:middle
in a city you're planning
on going and visiting.

00:02:19.176 --> 00:02:22.446 A:middle
But just based on what we
know about the United States,

00:02:22.676 --> 00:02:25.066 A:middle
this isn't a full object
graph, this is actually a piece

00:02:25.066 --> 00:02:26.866 A:middle
of an object graph, sub graph.

00:02:26.946 --> 00:02:29.176 A:middle
Because we know that the
United States has other states,

00:02:29.436 --> 00:02:31.336 A:middle
and those states
have other counties,

00:02:31.686 --> 00:02:34.076 A:middle
and those counties
have other cities.

00:02:34.546 --> 00:02:35.876 A:middle
And you know, beyond
that we know

00:02:35.876 --> 00:02:38.586 A:middle
that the United States is
only one of many countries.

00:02:40.486 --> 00:02:43.026 A:middle
And even in a guidebook I'm only
interested in sort of looking

00:02:43.026 --> 00:02:44.576 A:middle
at one set of data at a time.

00:02:44.616 --> 00:02:47.106 A:middle
If I'm planning a trip to
San Jose, I don't really care

00:02:47.106 --> 00:02:49.576 A:middle
about Oregon or Washington,
or anything like that.

00:02:49.576 --> 00:02:51.426 A:middle
I don't even really care
about San Francisco.

00:02:52.186 --> 00:02:54.226 A:middle
I need to be able to
get to those object,

00:02:54.226 --> 00:02:56.826 A:middle
to those destinations
if I'm interested

00:02:57.076 --> 00:02:59.306 A:middle
and change my mind later about
what I'm interested in browsing.

00:02:59.306 --> 00:03:02.036 A:middle
But for the immediate short
term, while I'm looking


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:02:59.306 --> 00:03:02.036 A:middle
But for the immediate short
term, while I'm looking

00:03:02.036 --> 00:03:05.356 A:middle
and planning my trip to Santa
Clara County, I don't care.

00:03:06.466 --> 00:03:09.786 A:middle
And that not caring
is represented by,

00:03:09.786 --> 00:03:12.986 A:middle
in memory a fault, it's an
object that knows how to go off

00:03:12.986 --> 00:03:16.206 A:middle
and retrieve data
later, at some point

00:03:16.726 --> 00:03:17.826 A:middle
if I decide I want to use it.

00:03:18.226 --> 00:03:20.056 A:middle
So say I find out my
friend is getting married

00:03:20.386 --> 00:03:22.526 A:middle
and her wedding's in
Seattle and I want to go,

00:03:22.526 --> 00:03:23.676 A:middle
you know plan a trip to Seattle.

00:03:24.336 --> 00:03:26.536 A:middle
So at this point I'm going to
navigate back up to the U.S.

00:03:26.536 --> 00:03:28.126 A:middle
and come down, I want
to look at Washington

00:03:28.426 --> 00:03:31.496 A:middle
and core data will automatically
retrieve the information

00:03:31.616 --> 00:03:34.956 A:middle
for Washington even
though it wasn't in memory

00:03:35.356 --> 00:03:37.156 A:middle
when I first loaded
the sub graph.

00:03:37.826 --> 00:03:41.046 A:middle
And you know, I can navigate
down from that and so on.

00:03:41.046 --> 00:03:45.236 A:middle
And that's what a fault is,
it's that future or promise,

00:03:45.236 --> 00:03:47.936 A:middle
or lazy loading, these
are all different names

00:03:47.936 --> 00:03:50.226 A:middle
for the same kind of
thing, that core data does

00:03:50.226 --> 00:03:52.156 A:middle
to help minimize the
amount of data you have

00:03:52.156 --> 00:03:53.356 A:middle
in memory at any given point.

00:03:54.686 --> 00:03:55.746 A:middle
Why do we use faults?

00:03:55.746 --> 00:03:57.176 A:middle
Well performance, performance,

00:03:57.176 --> 00:03:58.566 A:middle
performance, and
also performance.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:04:00.076 --> 00:04:02.466 A:middle
The best most performing
application is one

00:04:02.466 --> 00:04:03.936 A:middle
that doesn't do any
work you don't need.

00:04:04.766 --> 00:04:07.986 A:middle
You don't load objects over
the iobus, that you don't need.

00:04:08.086 --> 00:04:09.336 A:middle
You don't spend any
time [inaudible]

00:04:09.336 --> 00:04:11.136 A:middle
on objects that you don't need.

00:04:11.616 --> 00:04:14.716 A:middle
You don't want to have those
objects sitting around pushing

00:04:14.716 --> 00:04:16.576 A:middle
up your heaps high water mark

00:04:16.576 --> 00:04:18.495 A:middle
if your user's never
going to look at them.

00:04:19.206 --> 00:04:21.426 A:middle
But there is kind of
one issue with faults,

00:04:22.326 --> 00:04:23.406 A:middle
and it's sort of this.

00:04:23.866 --> 00:04:27.576 A:middle
Here we have that object
graph again, and in this case,

00:04:27.636 --> 00:04:28.696 A:middle
we've got a lot of faults.

00:04:29.436 --> 00:04:32.006 A:middle
And I'm navigating down my
tree and I go to Santa Clara

00:04:32.006 --> 00:04:34.106 A:middle
and I want to fire
the Cupertino fault.

00:04:34.576 --> 00:04:38.246 A:middle
But in the meantime, an external
process has been importing data

00:04:38.246 --> 00:04:40.786 A:middle
from the web and for whatever
reason it's deleted Cupertino.

00:04:41.366 --> 00:04:42.856 A:middle
Well, what happens?

00:04:42.856 --> 00:04:44.656 A:middle
I have a fault that's
supposed to go off

00:04:44.656 --> 00:04:47.336 A:middle
and retrieve information
about Cupertino

00:04:47.336 --> 00:04:49.116 A:middle
but there's no information
there anymore.

00:04:50.446 --> 00:04:53.256 A:middle
I said, I talked a lot about
not loading data you don't need,

00:04:53.256 --> 00:04:55.206 A:middle
but in this case, you
find yourself wondering,

00:04:55.316 --> 00:04:58.266 A:middle
well did I actually need
that data after all?

00:04:59.586 --> 00:04:59.936 A:middle
Oops.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:02.576 --> 00:05:04.766 A:middle
In core data right
now, you handle this

00:05:04.766 --> 00:05:06.736 A:middle
by using the
shouldDeleteInaccessibleFaults

00:05:06.736 --> 00:05:08.596 A:middle
property on
NSManagedObjectContext.

00:05:09.206 --> 00:05:11.606 A:middle
If you set that then
when the context notices

00:05:11.606 --> 00:05:13.936 A:middle
that you're trying to fire a
fault for a deleted object,

00:05:14.226 --> 00:05:16.896 A:middle
it will mark the fault as
being deleted and populate all

00:05:16.896 --> 00:05:18.806 A:middle
of its properties with nils.

00:05:19.286 --> 00:05:20.566 A:middle
This is mostly what
you're going to want

00:05:20.966 --> 00:05:22.286 A:middle
but sometimes it
can be inconvenient

00:05:22.286 --> 00:05:23.856 A:middle
because your UI doesn't
know how to deal

00:05:23.856 --> 00:05:25.596 A:middle
with you know, a nil identifier.

00:05:26.416 --> 00:05:28.286 A:middle
The other alternative is
to prefetch everything,

00:05:28.736 --> 00:05:31.126 A:middle
use relationship keypads
for prefetching to load all

00:05:31.126 --> 00:05:33.776 A:middle
of the objects you think
your user might want.

00:05:34.156 --> 00:05:35.746 A:middle
That moves you into
an escalating battle

00:05:35.746 --> 00:05:38.016 A:middle
with your user trying
to figure out exactly,

00:05:38.636 --> 00:05:41.056 A:middle
predict what they're going
to want, that can be tricky,

00:05:41.056 --> 00:05:42.726 A:middle
users are unpredictable,
we all know that.

00:05:43.336 --> 00:05:45.086 A:middle
The other alternative,
there is a third one,

00:05:45.086 --> 00:05:47.296 A:middle
there's always a third
one, write lots of code,

00:05:47.526 --> 00:05:49.486 A:middle
starting with using
existing object with ID

00:05:49.486 --> 00:05:52.056 A:middle
on the manage object context
to make sure that the object is

00:05:52.056 --> 00:05:53.796 A:middle
in the database before
you try the fault.

00:05:54.546 --> 00:05:57.116 A:middle
Write lots of try catch,
exceptional handlers

00:05:57.156 --> 00:05:58.726 A:middle
around all your fault firing

00:05:59.046 --> 00:06:01.146 A:middle
and frankly that's not
really fun code to write,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:05:59.046 --> 00:06:01.146 A:middle
and frankly that's not
really fun code to write,

00:06:01.196 --> 00:06:03.646 A:middle
you'd really rather be
writing interesting features

00:06:03.646 --> 00:06:05.836 A:middle
for your users to use,
because that's why they come

00:06:05.836 --> 00:06:07.906 A:middle
to your application,
because it does neat stuff.

00:06:08.776 --> 00:06:10.586 A:middle
But let's step back
for a second and think

00:06:10.586 --> 00:06:13.076 A:middle
about your user interacting
with your application.

00:06:13.486 --> 00:06:16.656 A:middle
The user view and the
UI often doesn't care

00:06:16.656 --> 00:06:18.456 A:middle
about seeing the
absolute latest,

00:06:18.456 --> 00:06:19.856 A:middle
freshest, snappiest data.

00:06:20.316 --> 00:06:21.196 A:middle
How do we know this?

00:06:22.566 --> 00:06:24.086 A:middle
Let's think about gas
pumps for a second.

00:06:25.076 --> 00:06:27.366 A:middle
Most of you are familiar
with them, you've put gas

00:06:27.366 --> 00:06:28.166 A:middle
in a car at some point.

00:06:28.886 --> 00:06:31.026 A:middle
Gas pumps have a display that
tells you how many gallons

00:06:31.026 --> 00:06:33.686 A:middle
or how many liters you've
actually put in your car.

00:06:34.186 --> 00:06:36.556 A:middle
And that display has
a thousandths field,

00:06:37.206 --> 00:06:39.326 A:middle
and I'd like a show of hands
for everybody who's capable

00:06:39.326 --> 00:06:42.136 A:middle
of reading that field,
in real time,

00:06:42.136 --> 00:06:43.316 A:middle
as they put gas in their car.

00:06:44.156 --> 00:06:46.376 A:middle
That's about what I expected,
none of you can process it,

00:06:46.376 --> 00:06:48.836 A:middle
the human brain wants data
sort of batched up neatly

00:06:48.896 --> 00:06:50.456 A:middle
in intervals that
it can understand.

00:06:51.166 --> 00:06:53.446 A:middle
So the user doesn't really
need latest, freshest data,

00:06:53.446 --> 00:06:54.426 A:middle
they just need it
to be, you know,

00:06:55.626 --> 00:06:56.786 A:middle
reasonably, quickly updated.

00:06:57.986 --> 00:07:00.296 A:middle
And a user who's saving
data, also doesn't care,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:06:57.986 --> 00:07:00.296 A:middle
And a user who's saving
data, also doesn't care,

00:07:00.486 --> 00:07:02.176 A:middle
this is why core data
has merge policies,

00:07:02.176 --> 00:07:03.866 A:middle
they want to make a bunch
of edits and they want

00:07:03.866 --> 00:07:05.976 A:middle
to have those edits saved
and mingled with whatever's

00:07:05.976 --> 00:07:07.986 A:middle
in the database and have
the right thing happen.

00:07:08.606 --> 00:07:09.876 A:middle
You pick the merge
policy you want

00:07:09.876 --> 00:07:12.936 A:middle
because you know your
users better than we do.

00:07:13.166 --> 00:07:16.476 A:middle
So what if we could take
this insight and build on it?

00:07:16.836 --> 00:07:20.156 A:middle
What if we could provide a way
to give your UI a stable view

00:07:20.156 --> 00:07:21.346 A:middle
of data in the database?

00:07:22.536 --> 00:07:24.506 A:middle
What if we could give you
a way to handle changes,

00:07:24.506 --> 00:07:25.856 A:middle
update changes
deterministically?

00:07:25.856 --> 00:07:28.706 A:middle
And what if we could
do all of this

00:07:28.756 --> 00:07:29.926 A:middle
so that you would
never see this again?

00:07:32.516 --> 00:07:36.196 A:middle
[ Applause ]

00:07:36.696 --> 00:07:38.596 A:middle
And now I can talk
about query generations.

00:07:39.736 --> 00:07:41.066 A:middle
Query generations are a way

00:07:41.066 --> 00:07:44.306 A:middle
of giving your manage object
context a basically a read

00:07:44.306 --> 00:07:46.306 A:middle
transaction on data
in the database.

00:07:46.906 --> 00:07:49.236 A:middle
All reads into that manage
object context are going

00:07:49.236 --> 00:07:52.456 A:middle
to see the same view of data
until you choose to advance it,

00:07:52.586 --> 00:07:55.336 A:middle
and you'll never see could
not fulfill a fault again.

00:07:55.336 --> 00:07:57.726 A:middle
And the important part is
we do this efficiently,

00:07:58.406 --> 00:07:59.886 A:middle
that's always been
the tricky bit.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:00.786 --> 00:08:02.016 A:middle
How do they work?

00:08:02.326 --> 00:08:04.086 A:middle
Well, I've got a
database, it has an object

00:08:04.086 --> 00:08:05.986 A:middle
in it, id 1, name fred.

00:08:06.216 --> 00:08:09.176 A:middle
And because these are
slides, I'm going to cut those

00:08:09.176 --> 00:08:11.266 A:middle
down because I need all the real
estate I can get for this built.

00:08:12.916 --> 00:08:15.236 A:middle
In a traditional database
that's what you've got,

00:08:15.386 --> 00:08:17.776 A:middle
you have one file, it has one
view of data in the world.

00:08:18.216 --> 00:08:19.586 A:middle
Using query generations though,

00:08:20.426 --> 00:08:22.416 A:middle
that becomes the
first generation

00:08:22.416 --> 00:08:23.646 A:middle
of data in your database.

00:08:25.126 --> 00:08:27.756 A:middle
And processes come along,
this can be your application,

00:08:27.756 --> 00:08:30.966 A:middle
it can be an importer, it can
be an extension on a watch,

00:08:31.076 --> 00:08:32.956 A:middle
something modifies the database.

00:08:34.676 --> 00:08:37.635 A:middle
A new generation is created.

00:08:37.716 --> 00:08:40.546 A:middle
And, more data is
created, new objects.

00:08:41.066 --> 00:08:44.296 A:middle
And at this point, the user
launches your application,

00:08:47.276 --> 00:08:49.566 A:middle
creates manage object
context and you load data.

00:08:50.206 --> 00:08:52.726 A:middle
And that context now
knows what generation

00:08:52.726 --> 00:08:54.466 A:middle
in the database it
loaded data from.

00:08:55.026 --> 00:08:59.456 A:middle
So as other processes or
contexts or whatever come along

00:08:59.456 --> 00:09:03.036 A:middle
and modify the database
some more,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:08:59.456 --> 00:09:03.036 A:middle
and modify the database
some more,

00:09:03.236 --> 00:09:04.656 A:middle
more generations are created,

00:09:05.196 --> 00:09:06.806 A:middle
that context still
knows its generation.

00:09:07.026 --> 00:09:11.456 A:middle
Second context comes up, loads
some data, makes some edits,

00:09:12.706 --> 00:09:16.306 A:middle
and saves and in saving it
creates a new generation

00:09:16.356 --> 00:09:19.326 A:middle
and tracks that it's now
representing generation,

00:09:19.636 --> 00:09:21.256 A:middle
in this case 6, in the database.

00:09:21.896 --> 00:09:24.946 A:middle
And at this point if we
fire a fault, in context 1,

00:09:25.446 --> 00:09:26.916 A:middle
even though the object
underlining

00:09:26.916 --> 00:09:29.426 A:middle
that fault may have been
deleted in generation 6,

00:09:29.716 --> 00:09:32.116 A:middle
it's still visible to the
context because it's still

00:09:32.116 --> 00:09:34.216 A:middle
in the database under
the label generation 3.

00:09:35.176 --> 00:09:39.406 A:middle
And at this point the user can
go make some edits in context 1,

00:09:39.446 --> 00:09:43.356 A:middle
delete some objects, change some
objects, insert new objects.

00:09:43.746 --> 00:09:46.356 A:middle
And when they save that context
core data will use the merge

00:09:46.356 --> 00:09:49.156 A:middle
policy to merge all of those
changes with whatever's

00:09:49.156 --> 00:09:53.216 A:middle
in the database and
create a new generation 7.

00:09:53.796 --> 00:09:56.976 A:middle
In the same way that context 1.

00:09:57.516 --> 00:09:59.906 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:10:00.406 --> 00:10:03.816 A:middle
In the same way that context 1
had visibility onto generation 3

00:10:03.816 --> 00:10:05.716 A:middle
when it was pinned
to generation 3.

00:10:06.296 --> 00:10:09.826 A:middle
Context 2 can do whatever it
would like with its objects,

00:10:09.936 --> 00:10:12.066 A:middle
turn them back into
faults, refire those faults,

00:10:12.376 --> 00:10:14.566 A:middle
and it will still see
the data as it existed

00:10:14.566 --> 00:10:16.526 A:middle
in generation 6 in the database.

00:10:17.756 --> 00:10:20.526 A:middle
So basically it's full
read transactionality

00:10:20.526 --> 00:10:21.976 A:middle
at the manage object
context level.

00:10:22.376 --> 00:10:25.706 A:middle
We've talked a lot
about how context have,

00:10:26.526 --> 00:10:28.056 A:middle
are essentially right
transactions

00:10:28.056 --> 00:10:29.836 A:middle
and now we've made them
read transactions as well.

00:10:30.146 --> 00:10:32.746 A:middle
So allows you to immediately
isolate your work on a context

00:10:32.746 --> 00:10:35.156 A:middle
by context level,
and minimize stuff

00:10:35.156 --> 00:10:37.146 A:middle
like preventive prefetching
which means,

00:10:37.146 --> 00:10:39.726 A:middle
you know, everybody wins.

00:10:40.616 --> 00:10:43.406 A:middle
Basics. An individual context
can choose what behavior it

00:10:43.406 --> 00:10:47.046 A:middle
wants, it can decide that it
wants the current behavior

00:10:47.046 --> 00:10:51.236 A:middle
that you're used to
in iOS 9 and macOS 11.

00:10:51.596 --> 00:10:55.376 A:middle
We call unpinned, see top
of tree when you load data.

00:10:55.506 --> 00:10:57.806 A:middle
You can also specify
that a context should pin

00:10:57.806 --> 00:10:59.826 A:middle
to whatever generation is
current in the database


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:00.026 --> 00:11:02.206 A:middle
when data is first
loaded into that context.

00:11:02.446 --> 00:11:04.446 A:middle
Or you can specify
that you want it to pin

00:11:04.446 --> 00:11:05.676 A:middle
to a specific generation

00:11:05.986 --> 00:11:08.156 A:middle
if you have another context
pinned to that generation.

00:11:09.686 --> 00:11:10.626 A:middle
Nested contacts are going

00:11:10.626 --> 00:11:12.516 A:middle
to inherit their
parents' generation,

00:11:12.996 --> 00:11:15.806 A:middle
they're implicitly unpinned
but they'll see data as viewed

00:11:15.806 --> 00:11:17.916 A:middle
through the, the
generation of their parent,

00:11:18.276 --> 00:11:20.726 A:middle
plus whatever pending changes
their parent has sitting

00:11:20.726 --> 00:11:21.746 A:middle
around unsaved.

00:11:24.616 --> 00:11:27.156 A:middle
Updates are kind of important,
we've all acknowledged that,

00:11:27.316 --> 00:11:28.616 A:middle
the user doesn't
want to see updates,

00:11:28.616 --> 00:11:32.416 A:middle
eventually they don't want to
see, you know 10 year-old data.

00:11:32.606 --> 00:11:35.276 A:middle
Generations are updated when
you explicitly tell a context

00:11:35.376 --> 00:11:37.456 A:middle
to update by setting a
new generation token.

00:11:37.796 --> 00:11:40.036 A:middle
They're updated on
save, they're updated

00:11:40.036 --> 00:11:42.276 A:middle
if you call mergeChanges,
will update to top of tree

00:11:42.276 --> 00:11:44.126 A:middle
at that point since you've
told the context that,

00:11:44.496 --> 00:11:46.646 A:middle
you know it should be looking
at a new set of changes

00:11:46.646 --> 00:11:48.986 A:middle
in the database,
and it's updated

00:11:49.306 --> 00:11:50.526 A:middle
as a result of calling reset.

00:11:51.126 --> 00:11:55.156 A:middle
Thing to note though is that,

00:11:56.086 --> 00:11:57.766 A:middle
registered objects
aren't refreshed

00:11:57.766 --> 00:12:00.266 A:middle
when you update the generation,
you may not want that,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:11:57.766 --> 00:12:00.266 A:middle
when you update the generation,
you may not want that,

00:12:00.726 --> 00:12:03.556 A:middle
and it's easy for us to let
you do it, it's a lot harder

00:12:03.556 --> 00:12:05.546 A:middle
to let you undo it if we
choose to do it for you.

00:12:05.546 --> 00:12:09.216 A:middle
If you want to refresh the data
you'll have to call a fetch

00:12:09.216 --> 00:12:12.426 A:middle
or refreshAllObjects, but it
gives you control over when

00:12:12.426 --> 00:12:14.116 A:middle
that data actually gets updated.

00:12:14.716 --> 00:12:18.456 A:middle
If you want to use query
generations you'll need

00:12:18.456 --> 00:12:20.836 A:middle
to be using and SQL store and
it needs to be in wall mode.

00:12:21.296 --> 00:12:22.986 A:middle
Although if you try and
use query generations

00:12:22.986 --> 00:12:24.906 A:middle
and you haven't met those
two requirements it will sort

00:12:24.906 --> 00:12:27.666 A:middle
of fail gracefully and just
revert to the unpinned behavior.

00:12:28.186 --> 00:12:30.036 A:middle
How did we do it?

00:12:30.346 --> 00:12:33.556 A:middle
Well, there's an now opaque
token that you can use

00:12:33.556 --> 00:12:34.836 A:middle
to track a query generation.

00:12:34.836 --> 00:12:37.146 A:middle
This will tell the
context, you know when

00:12:37.146 --> 00:12:41.236 A:middle
and what store it
loaded data from.

00:12:41.446 --> 00:12:43.406 A:middle
The query generation token
has a method current,

00:12:43.586 --> 00:12:45.516 A:middle
you can use to retrieve
a token to indicate

00:12:45.516 --> 00:12:47.736 A:middle
that a context should
pin when it loads data.

00:12:50.146 --> 00:12:52.546 A:middle
ManagedObjectContext, we
have a few new methods,

00:12:52.586 --> 00:12:54.956 A:middle
there's a property,
query generation token

00:12:54.956 --> 00:12:58.146 A:middle
that will tell you what query
generation a context is using.

00:12:58.536 --> 00:13:00.336 A:middle
It'll be nil if the
context is unpinned.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:12:58.536 --> 00:13:00.336 A:middle
It'll be nil if the
context is unpinned.

00:13:01.056 --> 00:13:03.376 A:middle
And you can set a query
generation from a token,

00:13:03.426 --> 00:13:06.726 A:middle
either the current token
from class property or,

00:13:07.416 --> 00:13:09.266 A:middle
the result of calling
queryGenerationToken

00:13:09.266 --> 00:13:11.466 A:middle
on another manage
object context.

00:13:12.796 --> 00:13:15.346 A:middle
A generation won't include
stores that were added

00:13:15.476 --> 00:13:18.146 A:middle
to the store coordinator after
the generation was created.

00:13:18.566 --> 00:13:21.066 A:middle
If you load data into a
manage object context,

00:13:21.256 --> 00:13:23.296 A:middle
add a store to the
coordinator and then do a fetch,

00:13:23.536 --> 00:13:25.336 A:middle
you will not see results
from that new store.

00:13:25.776 --> 00:13:28.146 A:middle
But it does not prevent
you from removing stores

00:13:28.146 --> 00:13:29.946 A:middle
from the coordinator, although
you're going to see an error

00:13:29.946 --> 00:13:34.906 A:middle
if you try and load data into a
context when you've removed all

00:13:34.906 --> 00:13:36.686 A:middle
of the stores that it was
trying to load data from.

00:13:37.176 --> 00:13:41.136 A:middle
And now I'm going to talk
about concurrency because,

00:13:41.716 --> 00:13:43.306 A:middle
well we always talk
about concurrency.

00:13:45.166 --> 00:13:47.396 A:middle
This is the current state
of affairs in core data,

00:13:47.796 --> 00:13:50.986 A:middle
and it's manage object
context is an actor.

00:13:50.986 --> 00:13:54.226 A:middle
You use perform and
performAndWait to interact

00:13:54.226 --> 00:13:56.306 A:middle
with it, do schedule
blocks for execution

00:13:56.346 --> 00:13:58.006 A:middle
on the managed object
context queue.

00:13:58.006 --> 00:14:00.686 A:middle
There is a third model,
which, or another model,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:13:58.006 --> 00:14:00.686 A:middle
There is a third model,
which, or another model,

00:14:00.686 --> 00:14:02.476 A:middle
which is to use the
confinementConcurrencyType

00:14:02.796 --> 00:14:04.636 A:middle
which allows you to
message the context directly

00:14:04.636 --> 00:14:06.906 A:middle
but that's deprecated
because it turns

00:14:06.906 --> 00:14:08.186 A:middle
out that that's really
hard to get right

00:14:08.606 --> 00:14:10.716 A:middle
in any threading situation.

00:14:11.656 --> 00:14:14.926 A:middle
The persistent store
coordinator is also an actor

00:14:14.926 --> 00:14:17.276 A:middle
and has the same API
perform and performAndWait.

00:14:17.276 --> 00:14:20.226 A:middle
And the coordinator will
serialize request coming

00:14:20.226 --> 00:14:23.066 A:middle
in from individual managed
object context along

00:14:23.066 --> 00:14:25.516 A:middle
with whatever request you've
directly scheduled using the

00:14:25.516 --> 00:14:28.256 A:middle
perform and performAndWait
APIs on the coordinate.

00:14:28.716 --> 00:14:32.706 A:middle
And at this point I'd like to
make an important announcement,

00:14:33.276 --> 00:14:35.626 A:middle
we have added, for those of
you who are programming in ObjC

00:14:35.626 --> 00:14:39.346 A:middle
and using manual retain
release, and auto release pool

00:14:39.346 --> 00:14:40.636 A:middle
around perform, block and wait.

00:14:40.636 --> 00:14:43.286 A:middle
This means that you're now
going to be responsible

00:14:43.286 --> 00:14:46.676 A:middle
for extending the lifespan
of any objects created

00:14:46.676 --> 00:14:48.756 A:middle
in the blocks you've
scheduled if you want

00:14:48.756 --> 00:14:50.496 A:middle
to use those objects
outside the block.

00:14:50.966 --> 00:14:52.826 A:middle
It's easy to remember to
do that for the results of,

00:14:52.826 --> 00:14:54.406 A:middle
for example an execute fetch.

00:14:54.816 --> 00:14:57.566 A:middle
It's a little bit less
immediately obvious

00:14:57.566 --> 00:14:59.596 A:middle
that you also need to
do this for any NSErrors

00:14:59.596 --> 00:15:00.616 A:middle
that may be being returned.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:14:59.596 --> 00:15:00.616 A:middle
that may be being returned.

00:15:01.436 --> 00:15:03.966 A:middle
This doesn't only affect people
using manual retain release

00:15:03.966 --> 00:15:06.446 A:middle
and we have a link time check
so you won't see this behavior

00:15:06.446 --> 00:15:10.196 A:middle
until you recompile
for iOS 10 or macOS 12.

00:15:10.926 --> 00:15:14.936 A:middle
But let's talk about concurrency
as it exists in the world today.

00:15:15.806 --> 00:15:18.856 A:middle
Or, as it exists in the
world until yesterday.

00:15:20.256 --> 00:15:24.666 A:middle
Context 1 tries to do
something that requires going

00:15:24.666 --> 00:15:27.446 A:middle
to the persistent store, so
it messages the coordinator.

00:15:28.296 --> 00:15:30.956 A:middle
Which, because its sterilizing
requests, takes a lock.

00:15:30.956 --> 00:15:32.206 A:middle
And at this point context 2,

00:15:32.206 --> 00:15:35.616 A:middle
which may be your UIContext
wants to do something and tries

00:15:35.616 --> 00:15:36.686 A:middle
to message the coordinator.

00:15:37.146 --> 00:15:40.366 A:middle
But because the coordinator is
locked, context 2 has to wait,

00:15:40.896 --> 00:15:45.416 A:middle
as the request from context 1 is
passed down to persistent store

00:15:45.796 --> 00:15:49.586 A:middle
and whatever work is necessary
to evaluate, evaluates.

00:15:50.056 --> 00:15:52.496 A:middle
And it's only when that
work finishes and the thread

00:15:52.496 --> 00:15:56.596 A:middle
of execution returns that
context 2 can take a lock

00:15:56.596 --> 00:15:59.026 A:middle
on the coordinator and
have its work dispatched

00:15:59.026 --> 00:15:59.716 A:middle
down to the store.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:00.066 --> 00:16:02.336 A:middle
And this means that context 2
is basically going to be blocked

00:16:02.336 --> 00:16:04.556 A:middle
on whatever work it is
that context 1 is doing.

00:16:05.206 --> 00:16:07.436 A:middle
And eventually it will return

00:16:07.436 --> 00:16:08.876 A:middle
but in the meantime
your IU might have,

00:16:08.936 --> 00:16:10.206 A:middle
you know been a little bit slow.

00:16:12.036 --> 00:16:16.506 A:middle
New stuff, the SQL store now has
a connection pool and is capable

00:16:16.506 --> 00:16:18.476 A:middle
of handling multiple
concurrent requests.

00:16:18.806 --> 00:16:21.676 A:middle
Specifically it can now
handle multiple readers

00:16:21.676 --> 00:16:24.856 A:middle
and a single writer, size of
the connection pool varies

00:16:24.856 --> 00:16:25.996 A:middle
from platform to platform.

00:16:26.716 --> 00:16:28.646 A:middle
We've adopted it and
we'll show you how

00:16:28.646 --> 00:16:30.536 A:middle
to change it in a couple slides.

00:16:31.006 --> 00:16:32.226 A:middle
So how does this work now?

00:16:33.096 --> 00:16:36.106 A:middle
Well context 1 dispatches
to the coordinator,

00:16:37.146 --> 00:16:38.986 A:middle
and well no lock is taken.

00:16:39.846 --> 00:16:43.786 A:middle
Context 2, which may still be
your UIContext also dispatches

00:16:43.816 --> 00:16:47.446 A:middle
the coordinator and both
of those messages are sent

00:16:47.446 --> 00:16:49.666 A:middle
down to the persistent
store at the same time.

00:16:50.636 --> 00:16:52.986 A:middle
Persistent store then does
whatever work it needs to figure

00:16:52.986 --> 00:16:55.316 A:middle
out what messages
it needs to SQLite

00:16:55.966 --> 00:16:57.546 A:middle
and those are sent
down to SQLite.

00:16:57.546 --> 00:16:59.756 A:middle
And it's only at that
point that a lock is taken,

00:16:59.756 --> 00:17:01.986 A:middle
and this is the standard
SQLite file block.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:16:59.756 --> 00:17:01.986 A:middle
and this is the standard
SQLite file block.

00:17:03.146 --> 00:17:07.316 A:middle
SQLite does whatever it needs
to do, begin opens transaction,

00:17:07.316 --> 00:17:09.796 A:middle
right it's a bunch of SQL,
closes the transaction,

00:17:11.215 --> 00:17:14.596 A:middle
ends at that point returns.

00:17:15.215 --> 00:17:17.435 A:middle
So you can see at this point
that we've really, really,

00:17:17.435 --> 00:17:19.826 A:middle
really decreased the scope of
the critical section there.

00:17:20.306 --> 00:17:22.096 A:middle
And why do you care?

00:17:22.376 --> 00:17:24.476 A:middle
This is going to make your
UI a lot more responsive,

00:17:24.856 --> 00:17:27.876 A:middle
you can fault and
fetch in, for example,

00:17:28.056 --> 00:17:31.436 A:middle
a main UI while background
work is happening

00:17:31.536 --> 00:17:32.846 A:middle
on a separate context.

00:17:33.606 --> 00:17:34.856 A:middle
And the immediate fallout

00:17:34.856 --> 00:17:36.846 A:middle
from this is it really
simplifies application

00:17:36.846 --> 00:17:38.926 A:middle
architecture, a fairly
standard pattern,

00:17:38.926 --> 00:17:43.256 A:middle
has been that people will have
an importer context that's

00:17:43.256 --> 00:17:45.186 A:middle
loading data for
example, from the web.

00:17:45.566 --> 00:17:49.246 A:middle
And another, a main UIContext
is vending data to the main UI.

00:17:50.556 --> 00:17:52.756 A:middle
And they end up having
these on separate stacks

00:17:52.896 --> 00:17:54.636 A:middle
because the UI needs
to be responsive

00:17:54.636 --> 00:17:57.076 A:middle
and they need the
critical section locking

00:17:57.076 --> 00:17:58.176 A:middle
to be as small as possible.

00:17:59.486 --> 00:18:01.696 A:middle
And the only way to get
that before when you had


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:17:59.486 --> 00:18:01.696 A:middle
And the only way to get
that before when you had

00:18:01.696 --> 00:18:04.966 A:middle
to lock the entire stack, was
to have two separate stacks.

00:18:05.346 --> 00:18:07.806 A:middle
And that introduced an issue
with doing hand offs between,

00:18:07.806 --> 00:18:10.226 A:middle
okay there's a manage object
context did save notification

00:18:10.226 --> 00:18:12.246 A:middle
but it's coming from an entirely
separate persistent store

00:18:12.246 --> 00:18:14.096 A:middle
coordinator and I need
to migrate that over.

00:18:15.116 --> 00:18:18.506 A:middle
That's no longer an issue there,
you can now attach both context

00:18:18.506 --> 00:18:21.936 A:middle
to the same persistent store
coordinator, they'll execute

00:18:21.936 --> 00:18:25.786 A:middle
in parallel and you can
just do standard merging,

00:18:25.786 --> 00:18:28.936 A:middle
and as a huge bonus this means
they're sharing the row cache

00:18:29.216 --> 00:18:31.116 A:middle
which is really going to
decrease your memory footprint.

00:18:31.116 --> 00:18:33.316 A:middle
It's going to divide
it by 2, since well,

00:18:33.616 --> 00:18:41.356 A:middle
we've only got one
row cache nowadays.

00:18:41.686 --> 00:18:47.286 A:middle
It's on by default, it's for SQL
stores only, and it only works

00:18:47.286 --> 00:18:48.706 A:middle
if all coordinated stores

00:18:48.706 --> 00:18:51.006 A:middle
on a persistent store
coordinator are SQL stores.

00:18:51.886 --> 00:18:53.336 A:middle
You can configure the size

00:18:53.336 --> 00:18:55.796 A:middle
of the connection pool
using the NSPersistentStore

00:18:55.796 --> 00:18:58.276 A:middle
ConnectionPoolMax
SizeKey, that allows you

00:18:58.416 --> 00:19:01.616 A:middle
to specify the maximum
size the connection pool.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:18:58.416 --> 00:19:01.616 A:middle
to specify the maximum
size the connection pool.

00:19:01.926 --> 00:19:03.846 A:middle
If you want serial
request handling,

00:19:03.846 --> 00:19:05.406 A:middle
the old behavior,
you can set it to 1.

00:19:05.916 --> 00:19:08.336 A:middle
We do reserve the right
to say you tried to set it

00:19:08.406 --> 00:19:10.636 A:middle
to one million and that's
kind of silly so we're going

00:19:10.636 --> 00:19:11.696 A:middle
to use a more reasonable number.

00:19:12.126 --> 00:19:17.236 A:middle
It should be transparent to
most of you right off the bat,

00:19:17.236 --> 00:19:19.486 A:middle
your UIs will possibly get
a little more responsive.

00:19:20.416 --> 00:19:22.716 A:middle
The big thing we noticed
internally once we turned this

00:19:22.716 --> 00:19:25.736 A:middle
on, was a whole bunch of
people said, hey, wow I can rip

00:19:25.736 --> 00:19:28.846 A:middle
out a couple hundred, couple
thousand lines of code.

00:19:29.316 --> 00:19:31.416 A:middle
And you should do it because man
is that satisfying [laughter].

00:19:32.256 --> 00:19:34.976 A:middle
A few of you.

00:19:35.516 --> 00:19:38.916 A:middle
[ Applause ]

00:19:39.416 --> 00:19:43.856 A:middle
A few of you may notice,
some minor timing issues.

00:19:43.856 --> 00:19:47.206 A:middle
If you had a context, context
1 that had a perform block

00:19:47.206 --> 00:19:49.696 A:middle
and wait and context 2 that also
had a perform block and wait,

00:19:49.946 --> 00:19:53.196 A:middle
originally context 2 would
not start executing its block

00:19:53.516 --> 00:19:56.846 A:middle
until context 1's block had
returned, that's no longer true.

00:19:56.846 --> 00:20:00.096 A:middle
So for the like .1% of you
who are in that situation,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:19:56.846 --> 00:20:00.096 A:middle
So for the like .1% of you
who are in that situation,

00:20:00.406 --> 00:20:01.976 A:middle
your timing's going to
change and you may need

00:20:01.976 --> 00:20:04.396 A:middle
to decrease the bandwidth
connection pool,

00:20:04.396 --> 00:20:05.116 A:middle
the rearchitect.

00:20:05.506 --> 00:20:08.526 A:middle
The rest of you, you'll
just get to build new

00:20:08.526 --> 00:20:09.706 A:middle
and interesting and
simpler code.

00:20:10.566 --> 00:20:12.716 A:middle
And at this point I'm
going to drag my co-worker,

00:20:12.716 --> 00:20:14.546 A:middle
Scott up on stage and
he's going to talk

00:20:14.546 --> 00:20:15.656 A:middle
about a bunch of other stuff.

00:20:16.516 --> 00:20:22.406 A:middle
[ Applause ]

00:20:22.906 --> 00:20:23.456 A:middle
&gt;&gt; Thanks Melissa.

00:20:26.136 --> 00:20:31.076 A:middle
Good morning, let's talk
about setting up core data,

00:20:32.726 --> 00:20:34.256 A:middle
starting with adding
a persistent store.

00:20:34.256 --> 00:20:36.856 A:middle
To add a persistent
store to a coordinator,

00:20:37.106 --> 00:20:39.016 A:middle
you need four pieces
of data and,

00:20:39.296 --> 00:20:41.276 A:middle
to do most operations
you need at least two.

00:20:41.356 --> 00:20:45.456 A:middle
New this year, core data has
introduced a new type called

00:20:45.456 --> 00:20:48.326 A:middle
NSPersistentStoreDescription
that encapsulates all

00:20:48.326 --> 00:20:49.886 A:middle
of the data needed
to describe a store

00:20:50.276 --> 00:20:53.816 A:middle
and also includes convenience
API for common options

00:20:53.816 --> 00:20:55.936 A:middle
like whether the store
should be opened read only,

00:20:56.406 --> 00:20:59.936 A:middle
the timeout that the coordinator
should use, automatic migration

00:20:59.936 --> 00:21:02.596 A:middle
and mapping options which are
both enabled by default now.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:20:59.936 --> 00:21:02.596 A:middle
and mapping options which are
both enabled by default now.

00:21:02.996 --> 00:21:05.626 A:middle
And a new option, for adding
stores asynchronously,

00:21:07.576 --> 00:21:09.386 A:middle
this new type works
with a new method

00:21:09.386 --> 00:21:10.866 A:middle
on the persistent
store coordinator

00:21:11.296 --> 00:21:14.046 A:middle
that takes a trail
enclosure with parameters

00:21:14.046 --> 00:21:17.666 A:middle
for the store description and an
optional NSError that is non-nil

00:21:17.666 --> 00:21:18.686 A:middle
if the operation failed.

00:21:19.796 --> 00:21:21.926 A:middle
If you're adding a store
asynchronously you can extend

00:21:21.926 --> 00:21:24.296 A:middle
the conditional in a
call back for things

00:21:24.296 --> 00:21:27.596 A:middle
like posting a notification or
pushing your application's UI

00:21:27.596 --> 00:21:29.356 A:middle
after the store has
been successfully added.

00:21:30.166 --> 00:21:33.706 A:middle
This way your app's model setup
can happen off the main thread

00:21:33.886 --> 00:21:36.096 A:middle
which is especially useful
when your application launches

00:21:36.096 --> 00:21:37.776 A:middle
since a migration
may cause a delay.

00:21:38.386 --> 00:21:41.206 A:middle
Remember, if iOS notices that
your app hasn't been responsive

00:21:41.206 --> 00:21:43.526 A:middle
for a while after launch,
then it will kill the app.

00:21:44.236 --> 00:21:47.126 A:middle
This can prevent a migration
from ever finishing but,

00:21:47.126 --> 00:21:48.396 A:middle
it's not a problem anymore

00:21:48.396 --> 00:21:49.836 A:middle
if you're adding a
store asynchronously.

00:21:50.406 --> 00:21:54.296 A:middle
So that's persistent
store descriptions but,

00:21:54.296 --> 00:21:56.776 A:middle
there's a lot more involved
in setting up core data stack.

00:21:57.496 --> 00:21:59.786 A:middle
To represent a core data stack
you need at least three objects,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:00.126 --> 00:22:02.466 A:middle
plus the boiler plate to
associate them with each other.

00:22:03.816 --> 00:22:06.176 A:middle
New this year, core data
has yet another type

00:22:06.176 --> 00:22:08.206 A:middle
that encapsulates
those objects and most

00:22:08.206 --> 00:22:10.516 A:middle
of the boiler plate called
NSPersistentContainer,

00:22:10.516 --> 00:22:12.376 A:middle
not only does it [laughter].

00:22:13.516 --> 00:22:17.146 A:middle
[ Applause ]

00:22:17.646 --> 00:22:19.856 A:middle
I realized a lot of you have
written this type yourselves

00:22:19.856 --> 00:22:23.336 A:middle
maybe but [laughter] this one
not only encapsulates modeling

00:22:23.336 --> 00:22:25.586 A:middle
configuration it
also has a name,

00:22:26.366 --> 00:22:28.726 A:middle
a list of store descriptions,
and a method

00:22:28.726 --> 00:22:31.396 A:middle
to load store descriptions
from that list

00:22:31.396 --> 00:22:33.176 A:middle
that haven't already been
added to the coordinator.

00:22:34.176 --> 00:22:36.066 A:middle
This means that the
project boiler plated needed

00:22:36.066 --> 00:22:38.436 A:middle
to setup core data goes
from an entire page of code

00:22:38.896 --> 00:22:40.916 A:middle
to just a couple of lines.

00:22:42.516 --> 00:22:50.876 A:middle
[ Applause ]

00:22:51.376 --> 00:22:53.226 A:middle
So there's a lot of
code missing here now,

00:22:53.226 --> 00:22:54.746 A:middle
let's take a look
at how it all works.

00:22:55.276 --> 00:22:57.576 A:middle
The container guarantees that
its properties are always valid

00:22:57.576 --> 00:23:00.436 A:middle
so the getters for things like
the coordinator and the model,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:22:57.576 --> 00:23:00.436 A:middle
so the getters for things like
the coordinator and the model,

00:23:00.436 --> 00:23:03.246 A:middle
will always return new
objects that are safe to use.

00:23:04.156 --> 00:23:06.936 A:middle
The container's initializer
finds a model based on the name

00:23:06.936 --> 00:23:08.216 A:middle
that you pass into
the initializer,

00:23:09.256 --> 00:23:10.556 A:middle
there's also another initializer

00:23:10.556 --> 00:23:12.266 A:middle
that takes an explicit
model argument.

00:23:13.716 --> 00:23:16.926 A:middle
By default, new containers
have a single store description

00:23:16.926 --> 00:23:19.846 A:middle
in the list, it's an
SQLite with default options

00:23:20.086 --> 00:23:23.086 A:middle
and a file name based on
the name of the container.

00:23:23.706 --> 00:23:27.126 A:middle
And it's stored in a directory
that's defined by a class method

00:23:27.126 --> 00:23:29.736 A:middle
on the container, and
a persistent container,

00:23:29.736 --> 00:23:33.466 A:middle
by default will return
you a directory based

00:23:33.466 --> 00:23:34.516 A:middle
on the platform that you're on.

00:23:34.516 --> 00:23:37.006 A:middle
So it will use the application
support directory on macOS,

00:23:37.526 --> 00:23:40.586 A:middle
your container document
structure on iOS and launchOS,

00:23:40.636 --> 00:23:43.346 A:middle
and your containers
caches directory on tvOS.

00:23:43.346 --> 00:23:47.956 A:middle
If you want to set your own
directory then you can subclass

00:23:47.956 --> 00:23:50.096 A:middle
in this persistent container
and override the direct,

00:23:50.296 --> 00:23:52.896 A:middle
sorry the defaulted
directory URL class method.

00:23:54.476 --> 00:23:56.846 A:middle
We think container's really
helpful for setting up core data

00:23:56.926 --> 00:23:58.546 A:middle
but they also provide
convenience

00:23:58.546 --> 00:23:59.666 A:middle
for common operations.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:00.266 --> 00:24:03.446 A:middle
Containers have a main queue
context property called view

00:24:03.446 --> 00:24:05.986 A:middle
context that you can
use to drive your UI.

00:24:06.316 --> 00:24:09.276 A:middle
There's also a factory method
that vends background contexts

00:24:09.276 --> 00:24:11.646 A:middle
that are ready to use
but most of the time,

00:24:12.076 --> 00:24:14.276 A:middle
you'll probably want to
use the container's method

00:24:14.276 --> 00:24:15.776 A:middle
for performing background tasks

00:24:15.776 --> 00:24:17.676 A:middle
which is called
performBackgroundTask.

00:24:18.306 --> 00:24:22.096 A:middle
So instead of having to setup a
new background context and wire

00:24:22.096 --> 00:24:23.556 A:middle
up and then a queue a
block just to do something

00:24:23.556 --> 00:24:25.946 A:middle
in the background you can just
pass a block to the container.

00:24:27.226 --> 00:24:29.036 A:middle
Using performBackgroundTask
can have a benefit to the

00:24:29.036 --> 00:24:31.886 A:middle
on code concision using it
gives core data the ability

00:24:31.886 --> 00:24:33.776 A:middle
to reduce the number of
contexts that are created

00:24:33.776 --> 00:24:36.766 A:middle
to do your work, and also can
work with connection pooling

00:24:36.766 --> 00:24:38.306 A:middle
to ensure that your
app stays responsive,

00:24:38.346 --> 00:24:39.336 A:middle
even under heavy load.

00:24:41.876 --> 00:24:43.636 A:middle
Speaking of common
context work flows,

00:24:44.036 --> 00:24:47.176 A:middle
the NSManagedObjectContext has
a new property this year called

00:24:47.176 --> 00:24:49.866 A:middle
automatically merges
changes from parent.

00:24:49.866 --> 00:24:51.236 A:middle
It's a Boolean and
when you set it

00:24:51.236 --> 00:24:53.016 A:middle
to true the context will
automatically merge,

00:24:53.016 --> 00:24:54.686 A:middle
save the change the
data of its parent.

00:24:55.446 --> 00:24:56.146 A:middle
This works for [laughter].

00:24:57.516 --> 00:25:00.156 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:24:57.516 --> 00:25:00.156 A:middle
[ Applause ]

00:25:00.656 --> 00:25:03.196 A:middle
This is really handy, it
works for child context

00:25:03.196 --> 00:25:06.736 A:middle
when the parent saves its
changes, and it also works

00:25:06.736 --> 00:25:09.546 A:middle
for top level context when a
sibling saves up to the store.

00:25:09.996 --> 00:25:12.406 A:middle
It works especially well
with generation tokens

00:25:12.406 --> 00:25:13.776 A:middle
which Melissa talked
about earlier.

00:25:14.826 --> 00:25:18.636 A:middle
So your UIs can be maintenance
free if you pin your UI context

00:25:18.636 --> 00:25:20.916 A:middle
to the latest generation and
then enable automatic merging,

00:25:21.226 --> 00:25:23.376 A:middle
your faults will be safe
and your object bindings

00:25:23.376 --> 00:25:25.756 A:middle
and fetch results controllers
will keep themselves

00:25:27.276 --> 00:25:29.626 A:middle
up to date [laughter].

00:25:30.496 --> 00:25:35.036 A:middle
Alright. Let's talk
about generics.

00:25:36.216 --> 00:25:38.686 A:middle
Core data has adopted generics
this year and they work great

00:25:38.686 --> 00:25:39.706 A:middle
in both ObjC and Swift.

00:25:39.706 --> 00:25:43.736 A:middle
There is a new protocol
called NSFetchRequestResult,

00:25:44.226 --> 00:25:48.316 A:middle
and it is adopted by all of the
types that you'd ever expect

00:25:48.316 --> 00:25:51.296 A:middle
to see back from the fetch
request like NSManagedObject

00:25:51.296 --> 00:25:52.946 A:middle
or all the entity subclasses.

00:25:53.416 --> 00:25:57.216 A:middle
Object IDs, NSDictionary
and NSNumber.

00:25:58.756 --> 00:26:01.266 A:middle
NSFetchRequest is now
parameterized based on the type


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:25:58.756 --> 00:26:01.266 A:middle
NSFetchRequest is now
parameterized based on the type

00:26:01.266 --> 00:26:02.886 A:middle
of the results which
is restricted

00:26:02.886 --> 00:26:05.876 A:middle
by protocol conformance and
in Swift, the fetch method

00:26:05.876 --> 00:26:08.156 A:middle
on NSManagedObjectContext
plums the type

00:26:08.156 --> 00:26:11.136 A:middle
of fetch request all the
way out to your results.

00:26:11.856 --> 00:26:13.716 A:middle
[Background noise] Finally,
a fetch results controller

00:26:13.766 --> 00:26:15.026 A:middle
who adopt the parameterization

00:26:15.026 --> 00:26:18.086 A:middle
of the fetch request
used to create it.

00:26:18.946 --> 00:26:20.516 A:middle
Speaking of
NSFetchResultsController,

00:26:20.736 --> 00:26:23.926 A:middle
if you're using UICollection
view, sorry there we go,

00:26:23.926 --> 00:26:25.676 A:middle
UICollection view,
it's really easy

00:26:25.676 --> 00:26:27.916 A:middle
to adopt the new data
source prefetching feature

00:26:28.376 --> 00:26:29.376 A:middle
if you're using core data.

00:26:29.786 --> 00:26:31.456 A:middle
All you need is an
asynchronous fetch request,

00:26:31.456 --> 00:26:34.266 A:middle
to get the request off the main
thread and you want to make sure

00:26:34.266 --> 00:26:35.916 A:middle
that you're not returning
objects as faults.

00:26:37.506 --> 00:26:39.386 A:middle
For more information about
data source prefetching,

00:26:39.386 --> 00:26:41.266 A:middle
check out Steve and
Peter's talk from yesterday,

00:26:41.426 --> 00:26:42.736 A:middle
what's new in UICollection view.

00:26:43.226 --> 00:26:46.966 A:middle
If you're a Mac developer I
also have good news for you.

00:26:47.426 --> 00:26:49.916 A:middle
The fetch results controller
is now available on macOS.

00:26:51.516 --> 00:26:54.546 A:middle
[ Applause ]

00:26:55.046 --> 00:26:58.226 A:middle
Okay, so let's talk about some
common operations in core data,

00:26:58.486 --> 00:27:00.646 A:middle
starting with getting
an entity description.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:26:58.486 --> 00:27:00.646 A:middle
starting with getting
an entity description.

00:27:01.666 --> 00:27:03.476 A:middle
Oops this, there we go.

00:27:04.526 --> 00:27:06.866 A:middle
For this you need the
entity's name as a string

00:27:06.866 --> 00:27:08.446 A:middle
and a managed object context.

00:27:09.536 --> 00:27:11.846 A:middle
Creating a fetch request also
requires a string constant

00:27:11.966 --> 00:27:13.316 A:middle
as well as a type
cast if you want

00:27:13.316 --> 00:27:14.836 A:middle
to take advantage
of the new generics.

00:27:15.616 --> 00:27:18.206 A:middle
And finally, there is
creating a new managed object

00:27:18.206 --> 00:27:20.176 A:middle
which has all three
things, a string constant,

00:27:20.306 --> 00:27:23.176 A:middle
a context parameter,
and a type cast.

00:27:24.026 --> 00:27:25.956 A:middle
These operations are all
getting easier this year

00:27:25.956 --> 00:27:28.576 A:middle
through improvements we've made
to manage object subclasses.

00:27:29.516 --> 00:27:32.316 A:middle
The entity description is now
a class method on the subclass.

00:27:34.516 --> 00:27:38.646 A:middle
[ Applause ]

00:27:39.146 --> 00:27:40.046 A:middle
Don't worry this gets
better [laughter].

00:27:40.706 --> 00:27:42.956 A:middle
The class also has
a factory method

00:27:42.956 --> 00:27:44.976 A:middle
for creating new fetch
requests that are fully typed.

00:27:46.516 --> 00:27:50.256 A:middle
[ Applause ]

00:27:50.756 --> 00:27:53.286 A:middle
And finally, you can
create a new manage object,

00:27:53.396 --> 00:27:56.046 A:middle
object using just the
subclass's initializer directly.

00:27:57.516 --> 00:28:03.916 A:middle
[ Applause ]


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:27:57.516 --> 00:28:03.916 A:middle
[ Applause ]

00:28:04.416 --> 00:28:06.326 A:middle
There's one more thing
that's worth talking

00:28:06.326 --> 00:28:08.116 A:middle
about which is performing
a fetch request.

00:28:08.456 --> 00:28:10.616 A:middle
I mentioned earlier that
the context fetch method is

00:28:10.616 --> 00:28:13.996 A:middle
parameterized in Swift but ObjC
doesn't support method level

00:28:13.996 --> 00:28:15.986 A:middle
generics, so we've
also added actor

00:28:15.986 --> 00:28:17.676 A:middle
like semantics to
fetch requests.

00:28:18.066 --> 00:28:19.926 A:middle
So you can just call
its execute method

00:28:20.186 --> 00:28:22.146 A:middle
from inside a block
submitted to a context

00:28:22.146 --> 00:28:25.976 A:middle
and it will return
properly typed results.

00:28:26.516 --> 00:28:29.106 A:middle
[ Applause ]

00:28:29.606 --> 00:28:31.876 A:middle
All this new API for model
subclasses should make a lot

00:28:31.876 --> 00:28:33.796 A:middle
of things much easier
but I'm guessing

00:28:33.796 --> 00:28:35.686 A:middle
that you're not really looking
forward to regenerating all

00:28:35.686 --> 00:28:38.796 A:middle
of your subclasses, but
don't worry because,

00:28:38.796 --> 00:28:41.396 A:middle
this should be the last year you
have to do anything with them.

00:28:42.036 --> 00:28:44.796 A:middle
Because Xcode 8 can now generate
that code for you automatically.

00:28:46.516 --> 00:28:49.546 A:middle
[ Applause ]

00:28:50.046 --> 00:28:51.836 A:middle
You can configure code
generation per entity

00:28:51.976 --> 00:28:53.666 A:middle
and Xcode will write
the generated code

00:28:53.666 --> 00:28:55.006 A:middle
to your project's derived data

00:28:55.006 --> 00:28:56.556 A:middle
so it doesn't pollute
your source tree

00:28:56.556 --> 00:28:57.476 A:middle
with code you didn't write.

00:28:58.296 --> 00:28:59.666 A:middle
You don't want to
edit these files

00:28:59.666 --> 00:29:01.416 A:middle
since the code is
automatically regenerated


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:28:59.666 --> 00:29:01.416 A:middle
since the code is
automatically regenerated

00:29:01.416 --> 00:29:04.646 A:middle
when you change your model
but if you want to do things

00:29:04.646 --> 00:29:06.376 A:middle
like add your own instance
variables or something

00:29:06.376 --> 00:29:08.686 A:middle
to the subclass, then
you can also tell Xcode

00:29:08.686 --> 00:29:10.596 A:middle
to only generate a
category or extension

00:29:10.596 --> 00:29:12.156 A:middle
and then you can own
the class itself.

00:29:14.976 --> 00:29:16.866 A:middle
In Swift all you need to do

00:29:16.866 --> 00:29:18.686 A:middle
to use this feature
is import the module

00:29:18.686 --> 00:29:21.116 A:middle
that your entities belong to
which is often the same module

00:29:21.116 --> 00:29:23.606 A:middle
as your code, but
in ObjC you'll need

00:29:23.606 --> 00:29:25.436 A:middle
to know a bit more
about how this works.

00:29:26.276 --> 00:29:27.526 A:middle
The most important file in,

00:29:27.526 --> 00:29:30.986 A:middle
to know about in ObjC is the
core data model header file.

00:29:31.776 --> 00:29:34.116 A:middle
Each model has its own header
file and you need to import it

00:29:34.116 --> 00:29:36.606 A:middle
to get access to all of that
model's generated classes.

00:29:37.696 --> 00:29:40.066 A:middle
If we zoom in for a look at
the other generated files

00:29:40.166 --> 00:29:42.286 A:middle
for entities configured
to generate classes,

00:29:42.286 --> 00:29:45.136 A:middle
Xcode creates two headers that
you probably already recognize

00:29:45.136 --> 00:29:46.566 A:middle
from generating classes
yourself.

00:29:47.006 --> 00:29:48.446 A:middle
One declares the class interface

00:29:48.496 --> 00:29:50.536 A:middle
and the other declares
the managed properties.

00:29:51.506 --> 00:29:53.956 A:middle
This is mostly important
to know for ObjC

00:29:53.956 --> 00:29:55.946 A:middle
because if you're
generating a category,

00:29:55.946 --> 00:29:58.136 A:middle
then Xcode will not
generate a class interface,

00:29:58.436 --> 00:30:01.016 A:middle
and the model's header will
import the category directly.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:29:58.436 --> 00:30:01.016 A:middle
and the model's header will
import the category directly.

00:30:02.406 --> 00:30:04.636 A:middle
Categories can't be declared
without a class interface

00:30:04.636 --> 00:30:06.926 A:middle
so the generated code
expects to find a header

00:30:06.926 --> 00:30:09.476 A:middle
in your project that's
named after the class.

00:30:09.796 --> 00:30:12.126 A:middle
This is a file that you
own, and if it doesn't exist

00:30:12.126 --> 00:30:14.196 A:middle
in your project then your
target will fail to build.

00:30:16.146 --> 00:30:18.356 A:middle
So let's take a quick break
from slides and have a look

00:30:18.356 --> 00:30:19.856 A:middle
at what all this new
stuff means for you.

00:30:19.976 --> 00:30:26.836 A:middle
I have Xcode 8 open
here and we're going

00:30:26.836 --> 00:30:28.186 A:middle
to create a new Xcode project.

00:30:28.826 --> 00:30:32.256 A:middle
And use iOSes master
detail application.

00:30:33.206 --> 00:30:36.176 A:middle
We've updated the templates
this year to use the new UI.

00:30:36.486 --> 00:30:42.566 A:middle
So if we, save this somewhere
and go to the app delegate,

00:30:43.316 --> 00:30:44.826 A:middle
then we can see that,

00:30:45.776 --> 00:30:48.916 A:middle
we're using a persistent
container here and we're wiring

00:30:48.916 --> 00:30:51.956 A:middle
up the master view controller

00:30:52.406 --> 00:30:54.206 A:middle
with the container's
view context.

00:30:54.206 --> 00:30:57.426 A:middle
If we go to the master
view controller,

00:30:57.976 --> 00:31:01.086 A:middle
we can see where it
creates a new object


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:30:57.976 --> 00:31:01.086 A:middle
we can see where it
creates a new object

00:31:01.206 --> 00:31:04.926 A:middle
that we're already using
subclass initializers

00:31:05.706 --> 00:31:07.206 A:middle
that are generated by core data.

00:31:07.606 --> 00:31:11.426 A:middle
And we're not using KVC anymore
we can set properties directly

00:31:11.496 --> 00:31:14.526 A:middle
on the manage object and if
we command click we get taken

00:31:14.526 --> 00:31:15.896 A:middle
to the generated file.

00:31:16.256 --> 00:31:20.176 A:middle
If we come back and we look

00:31:20.176 --> 00:31:22.146 A:middle
at how the fetch results
controller is set up,

00:31:23.016 --> 00:31:23.496 A:middle
there we are.

00:31:24.096 --> 00:31:28.246 A:middle
We can see that raising the
fetch request factory method

00:31:28.246 --> 00:31:29.556 A:middle
on the event subclass

00:31:30.126 --> 00:31:34.066 A:middle
and there's no extra
explicit typing here

00:31:34.066 --> 00:31:37.316 A:middle
when we create the fetch
results controller but its type,

00:31:38.196 --> 00:31:40.006 A:middle
which is really tiny,
but if we zoom in here,

00:31:41.176 --> 00:31:42.776 A:middle
is passed through from
the fetch request.

00:31:44.036 --> 00:31:47.576 A:middle
This means that elsewhere,
in the sub,

00:31:47.766 --> 00:31:52.976 A:middle
prepare for segue, there we go.

00:31:53.636 --> 00:31:55.926 A:middle
When we get an object from the
fetch results controller it

00:31:55.926 --> 00:31:56.966 A:middle
comes back with the right type.

00:31:58.456 --> 00:32:01.076 A:middle
So that's all great we
have no type cast anymore.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:31:58.456 --> 00:32:01.076 A:middle
So that's all great we
have no type cast anymore.

00:32:01.726 --> 00:32:06.876 A:middle
And, but I don't want this
app to show timestamps

00:32:06.876 --> 00:32:08.886 A:middle
in the master view controller
like it does by default.

00:32:08.886 --> 00:32:12.756 A:middle
So let's add a title attribute
to our event entity here.

00:32:13.266 --> 00:32:19.876 A:middle
And we want it to
be a string type.

00:32:20.576 --> 00:32:22.896 A:middle
Alright so we've
rebuilt, saved our model,

00:32:22.986 --> 00:32:25.966 A:middle
and if we go back here
and go to configure cell,

00:32:26.056 --> 00:32:29.376 A:middle
and we can delete
this code here.

00:32:29.996 --> 00:32:33.566 A:middle
And take advantage of
Xcode's auto completion

00:32:33.566 --> 00:32:36.206 A:middle
to get a new property that
we just set up in our model.

00:32:38.516 --> 00:32:42.656 A:middle
[ Applause ]

00:32:43.156 --> 00:32:44.696 A:middle
And again if we command
click on it,

00:32:45.156 --> 00:32:46.396 A:middle
all of the code has
been updated.

00:32:47.516 --> 00:32:52.256 A:middle
[ Applause ]

00:32:52.756 --> 00:32:54.896 A:middle
One of the best hidden
benefits of this is

00:32:54.896 --> 00:32:56.926 A:middle
if you're using manually
generated subclasses

00:32:56.926 --> 00:33:00.116 A:middle
or even KVC, if you change
the name of an attribute,


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:32:56.926 --> 00:33:00.116 A:middle
or even KVC, if you change
the name of an attribute,

00:33:00.356 --> 00:33:01.986 A:middle
you can wind up with
some really weird bugs

00:33:02.026 --> 00:33:05.856 A:middle
because your project
compiles but when it comes

00:33:05.856 --> 00:33:08.946 A:middle
to actually making the calls
you get a run time error,

00:33:08.946 --> 00:33:10.796 A:middle
because the key path
doesn't exist anymore.

00:33:11.456 --> 00:33:13.226 A:middle
Automatically subclass
generation takes care

00:33:13.226 --> 00:33:14.026 A:middle
of all of this.

00:33:15.446 --> 00:33:19.166 A:middle
So let's automatic
subclass generation as well

00:33:19.166 --> 00:33:21.556 A:middle
as some working examples
of core data's new API.

00:33:24.986 --> 00:33:27.416 A:middle
Last, let's talk about
what's new in SQLite.

00:33:28.876 --> 00:33:30.276 A:middle
The SQLite library that comes

00:33:30.276 --> 00:33:32.066 A:middle
with the operating
system has some new tricks

00:33:32.066 --> 00:33:33.416 A:middle
that you won't find
anywhere else.

00:33:33.476 --> 00:33:35.806 A:middle
The first of which is
multi-threading assertions.

00:33:37.126 --> 00:33:40.436 A:middle
SQLite on Apple platforms does
not have thread safe connections

00:33:40.726 --> 00:33:42.956 A:middle
and multi-threading bugs
can be hard to diagnose,

00:33:43.176 --> 00:33:45.876 A:middle
sometimes because they usually
manifest as a crash report

00:33:45.876 --> 00:33:48.426 A:middle
with a single thread
deep inside SQLite.

00:33:49.576 --> 00:33:51.176 A:middle
To make these issues
easier to identify

00:33:51.176 --> 00:33:53.656 A:middle
and reproduce the system
SQLite supports new environment

00:33:53.656 --> 00:33:55.966 A:middle
variable that enables
multi-threading assertions

00:33:56.246 --> 00:33:58.936 A:middle
when they fire you'll see
two threads in SQLite,

00:33:59.316 --> 00:34:01.086 A:middle
and they're both using
the same connection.


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:33:59.316 --> 00:34:01.086 A:middle
and they're both using
the same connection.

00:34:01.946 --> 00:34:06.566 A:middle
SQLite has always supported
user defined logging functions

00:34:06.566 --> 00:34:09.726 A:middle
through a configuration that
you can set using SQLite3 config

00:34:10.076 --> 00:34:11.196 A:middle
but that function needs

00:34:11.196 --> 00:34:13.286 A:middle
to be called before the
library is initialized

00:34:13.286 --> 00:34:14.505 A:middle
which may have already happened.

00:34:15.496 --> 00:34:17.096 A:middle
SQLite configurability is great

00:34:17.226 --> 00:34:18.795 A:middle
but we're running
a modeling system

00:34:18.795 --> 00:34:20.366 A:middle
that has built-in
logging facilities

00:34:20.366 --> 00:34:22.246 A:middle
so there's now another
environment variable

00:34:22.616 --> 00:34:24.795 A:middle
that chimes SQLite
logging to the system log.

00:34:26.556 --> 00:34:30.806 A:middle
Finally, I want to talk
about file operations.

00:34:32.166 --> 00:34:34.876 A:middle
All databases are represented
by a combination of files

00:34:34.876 --> 00:34:37.146 A:middle
and file operations
cannot be atomic

00:34:37.636 --> 00:34:38.676 A:middle
when they're in multiple files.

00:34:39.166 --> 00:34:41.366 A:middle
The result of this is that
all file operations are

00:34:41.366 --> 00:34:42.485 A:middle
inherently unsafe.

00:34:42.996 --> 00:34:45.826 A:middle
Unix file APIs to
NSFileManager, everything.

00:34:46.686 --> 00:34:48.976 A:middle
This is really important
and I want to share a couple

00:34:48.976 --> 00:34:51.005 A:middle
of concrete examples of
how things can go wrong.

00:34:52.496 --> 00:34:55.096 A:middle
Let's say I notice two database
files in the directory and,

00:34:56.366 --> 00:34:58.856 A:middle
my code wants to do some clean
up so it deletes them but in

00:34:58.856 --> 00:35:00.136 A:middle
between deleting the database


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:34:58.856 --> 00:35:00.136 A:middle
between deleting the database

00:35:00.136 --> 00:35:02.186 A:middle
and the journal something
connects to the database file.

00:35:02.836 --> 00:35:04.936 A:middle
That database doesn't have
access to the journal,

00:35:05.596 --> 00:35:07.426 A:middle
so it can't make
sense of the database,

00:35:07.596 --> 00:35:09.446 A:middle
so it starts reporting
errors immediately

00:35:09.556 --> 00:35:10.676 A:middle
which affects your app.

00:35:11.846 --> 00:35:14.046 A:middle
Unless you can guarantee
that nothing is currently

00:35:14.046 --> 00:35:16.166 A:middle
or it will ever try to
connect to a database,

00:35:16.166 --> 00:35:17.956 A:middle
it's not safe to
delete its files.

00:35:19.266 --> 00:35:21.196 A:middle
Let's say I have a
database in wall mode

00:35:21.726 --> 00:35:23.216 A:middle
and something is using it,

00:35:23.836 --> 00:35:26.176 A:middle
and the database finally gets
moved aside for some reason.

00:35:26.716 --> 00:35:29.536 A:middle
When it gets open
in its new location

00:35:29.536 --> 00:35:31.616 A:middle
that connection creates a
new journal and lock file,

00:35:32.336 --> 00:35:33.266 A:middle
now you have two connections

00:35:33.266 --> 00:35:34.916 A:middle
that are using different
journals and locks,

00:35:35.046 --> 00:35:37.416 A:middle
it's not long before they wind
up corrupting the database.

00:35:39.316 --> 00:35:42.376 A:middle
These examples may seem
contrived or rare, but there are

00:35:42.376 --> 00:35:45.406 A:middle
over a billion devices out there
with potential for problems

00:35:45.406 --> 00:35:47.796 A:middle
with every possible operation
on every possible file,

00:35:47.926 --> 00:35:49.746 A:middle
something will happen to
someone using your app

00:35:49.746 --> 00:35:52.286 A:middle
and they'll be very upset when
they wind up losing their data.

00:35:53.746 --> 00:35:55.086 A:middle
Hard links are especially bad,

00:35:55.626 --> 00:35:58.676 A:middle
don't use hard links
with database files.

00:35:59.176 --> 00:36:02.436 A:middle
So, new this year the
SQLite library that comes


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:35:59.176 --> 00:36:02.436 A:middle
So, new this year the
SQLite library that comes

00:36:02.436 --> 00:36:05.046 A:middle
with the operating system takes
advantage of dispatch sources

00:36:05.486 --> 00:36:07.576 A:middle
and database connections
will report errors

00:36:07.636 --> 00:36:10.106 A:middle
after an illegal operation
affects their files.

00:36:10.876 --> 00:36:13.486 A:middle
On its own the system solve
data corruption problems

00:36:13.486 --> 00:36:15.506 A:middle
in most cases the damages
has already been done.

00:36:15.926 --> 00:36:17.376 A:middle
So to help you identify

00:36:17.376 --> 00:36:20.136 A:middle
and debug these issues we've
added another environment

00:36:20.136 --> 00:36:22.986 A:middle
variable that causes
connections to assert as soon

00:36:22.986 --> 00:36:24.856 A:middle
as they detect an illegal
operation has affected

00:36:24.856 --> 00:36:25.426 A:middle
their files.

00:36:26.836 --> 00:36:27.766 A:middle
If you're curious for more ways

00:36:27.766 --> 00:36:29.186 A:middle
that your database
can get corrupted,

00:36:29.186 --> 00:36:31.046 A:middle
SQLite has an instructional
manual

00:36:31.046 --> 00:36:32.696 A:middle
on their website called how

00:36:32.696 --> 00:36:34.116 A:middle
to corrupt a SQLite
database file [laughter].

00:36:37.266 --> 00:36:41.626 A:middle
Luckily these problems
are avoidable.

00:36:42.396 --> 00:36:44.296 A:middle
If you're using SQLite
directly, you want to make sure

00:36:44.296 --> 00:36:46.556 A:middle
that there's only one piece of
code that owns that database

00:36:46.936 --> 00:36:49.486 A:middle
and that code needs to go
into the exclusive file access

00:36:49.486 --> 00:36:51.216 A:middle
so files can't be
changed when they're open.

00:36:52.316 --> 00:36:54.136 A:middle
If you're using core
data, and you should,

00:36:54.376 --> 00:36:56.326 A:middle
there's API in the
persistent store coordinator

00:36:56.416 --> 00:36:58.506 A:middle
that is always safe to
use with SQLite databases,

00:36:58.506 --> 00:36:59.446 A:middle
whether they're open or not.

00:36:59.986 --> 00:37:02.946 A:middle
There's replacePersistentStore
which replaces one database


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:36:59.986 --> 00:37:02.946 A:middle
There's replacePersistentStore
which replaces one database

00:37:02.946 --> 00:37:03.996 A:middle
with the contents of another.

00:37:03.996 --> 00:37:05.956 A:middle
And there's also
destroyPersistentStore

00:37:05.956 --> 00:37:08.086 A:middle
which safely deletes
everything in the database

00:37:08.086 --> 00:37:09.686 A:middle
and leaves an empty
database behind.

00:37:10.166 --> 00:37:15.976 A:middle
Alright, that's it for what's
new in core data this year.

00:37:16.316 --> 00:37:19.056 A:middle
To recap, we have a new
feature called query generations

00:37:19.056 --> 00:37:21.886 A:middle
which gives you a stable view of
your data at a snapshot in time.

00:37:23.176 --> 00:37:24.256 A:middle
We use support connection
pooling

00:37:24.256 --> 00:37:25.716 A:middle
and a persistent
store coordinator now

00:37:25.806 --> 00:37:27.866 A:middle
which allows multiple
readers at the same time

00:37:27.866 --> 00:37:30.646 A:middle
as a single writer, allowing
you to keep snappy interfaces

00:37:30.646 --> 00:37:32.246 A:middle
at the same time that you're
doing a lot of data work.

00:37:33.876 --> 00:37:35.656 A:middle
Setting up core data
is a lot easier

00:37:35.706 --> 00:37:37.936 A:middle
and then using it is also
a lot easier with new API,

00:37:38.086 --> 00:37:39.796 A:middle
that works especially
well in Swift.

00:37:40.446 --> 00:37:43.126 A:middle
This is all supported by great
new integration with Xcode

00:37:43.466 --> 00:37:46.016 A:middle
and we also have new
features in SQLite

00:37:46.456 --> 00:37:48.956 A:middle
that should make debugging
common problems much easier.

00:37:52.256 --> 00:37:53.816 A:middle
For more information,
please check

00:37:53.816 --> 00:37:56.786 A:middle
out the developer website,
this was session 242.

00:37:58.056 --> 00:38:00.266 A:middle
If you want to know more,
there's what's new in Swift


WEBVTT
X-TIMESTAMP-MAP=MPEGTS:181083,LOCAL:00:00:00.000

00:37:58.056 --> 00:38:00.266 A:middle
If you want to know more,
there's what's new in Swift

00:38:00.436 --> 00:38:01.606 A:middle
as well as what's new in Cocoa.

00:38:01.606 --> 00:38:02.976 A:middle
Thanks for coming.

00:38:03.516 --> 00:38:13.820 A:middle
[ Applause ]

